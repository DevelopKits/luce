{"name":"Luce","tagline":"Luce - a GUI module for Lua based on JUCE","body":"![image](http://peersuasive.github.io/images/lua-inside.png)\r\n\r\n`Luce` 0.3.1 *overall impression* [released !](https://github.com/peersuasive/luce/releases/tag/v0.3.1)\r\n\r\n[Downloads](#Downloads) for Linux, Windows, OS X, iOS and Android are available.\r\n\r\n# What is `Luce` ?\r\n\r\n`Luce` is a [Lua](http://lua.org) module for GUI programming based on\r\nthe portable, embeddable, remarkable C++ library [JUCE](http://www.juce.com).\r\n\r\nIt can be used as an ordinary module for pure lua 5.1/lua 5.2/luajit 2.X\r\nscripts or as a library for C++/Lua projects.\r\n\r\nAlthough based on JUCE, Luce isn't aiming at becoming a binding for\r\nJUCE, though the low level API free of Luce features could be used as\r\nsuch.\r\n\r\nLuce has Lua in mind and will be developped for lua developpers.\r\n\r\nLua essence is to be\r\n\"`a powerfull, fast, lightweight embeddable scripting language.`\" And so\r\nwould Luce be too.\r\n\r\nLuce is light, fast and [easily portable](https://github.com/peersuasive/luce_embeddable), thanks to Lua\r\nand JUCE itself.\r\n\r\nAs of now, it's supported on Linux, Windows and Mac OS X, with partial\r\nsupport for iOS and Android.\r\n\r\n# Getting started\r\n\r\n1.  [download](#downloads) the lua module for your environment\r\n2.  put it somewhere in your lua modules path (ex:\r\n    `/usr/local/share/lua/5.1`)\r\n\r\n-   if you're on Linux, you can also use the provided\r\n    [luarock](https://github.com/peersuasive/luce/raw/master/luce-scm-0.rockspec)\r\n-   if you don't know JUCE, you should consider having a look at its\r\n    [documentation](https://www.juce.com/api/annotated.html) as Luce low\r\n    level API matches for the most part JUCE's own API.\r\n\r\n    For more explanations, see [Differences with JUCE](#Differences with JUCE) and [Luce design](#Luce design).\r\n\r\n## A first app: say hello\r\n\r\n```lua\r\nlocal title = \"Hello World!\"\r\n\r\nlocal app, luce = require\"luce.LApplication\"(title, ...) -- create a basic Application\r\n                                                         -- with command line parameters\r\n\r\nlocal timer = luce:Timer() -- a timer for the animation\r\n\r\nlocal function MainWindow(args)  -- our main component class\r\n                                 -- will receive command line arguments or starting events\r\n\r\n    local app, luce = app, luce    -- just to put these in the local environment\r\n    local Colours   = luce.Colours -- id.\r\n    local wsize     = {800,600}    -- the size of our window\r\n    local isPaused  = false        -- holds the animation state\r\n\r\n    local mc = luce:MainComponent(\"MainComponent\") -- our main component\r\n    local documentWindow = luce:Document(title)    -- create a document window to hold the main component\r\n\r\n    local button = luce:TextButton(\"quit\")  -- a button to close the app\r\n    button.buttonText = \"Quit\"              -- visible text of the button\r\n    button:setLookAndFeel(4)                -- change look-and-feel\r\n    button.bounds     = { 10, 10, 100, 20 } -- and position it (x,y,w,h)\r\n\r\n    ---\r\n    -- set some action on button click\r\n    ---\r\n    button:buttonClicked(function()\r\n        app:quit()\r\n    end)\r\n\r\n    ---\r\n    -- say hello to the world with a simple animation\r\n    ---\r\n\r\n    -- just a dumb function to increase font size and pick a predefined colour\r\n    local currentSize, baseSize, maxSize = 12.0, 12.0, 32.0\r\n    local colours    = { Colours.black, Colours.red, Colours.yellow, Colours.green, Colours.blue }\r\n    local currentCol = 1\r\n    local function changeSize()\r\n        currentSize = (currentSize<maxSize) and currentSize+0.5 or baseSize\r\n        currentCol  = (currentCol>#colours) and 1 or currentCol+1\r\n        return currentSize, colours[currentCol]\r\n    end\r\n\r\n    -- draw the message\r\n    mc:paint(function(g)\r\n        -- draw a background\r\n        g:fillCheckerBoard( luce:Rectangle(mc:getBounds()), 48, 48, Colours.lightgrey, Colours.white) \r\n        -- get new font size and colour\r\n        local size, colour = changeSize()\r\n        -- draw text\r\n        g:setFont(size)\r\n        g:setColour(luce:Colour(colour))\r\n        g:drawText(\"Hello World!\", mc:getLocalBounds(), luce.JustificationType.centred, true);\r\n    end)\r\n\r\n    -- animate it a bit via the timer callback\r\n    timer:timerCallback(function()\r\n        if(mc:isShowing() and not(isPaused))then\r\n            mc:repaint()\r\n        end\r\n    end)\r\n    timer:startTimer (1000/60)\r\n\r\n    ---\r\n    -- add some key shortcuts\r\n    ---\r\n    local K  = string.byte \r\n    local kc = setmetatable( \r\n        luce.KeyPress.KeyCodes, { __index = function()return 0 end } ) -- just a little trick to always get a valid keycode\r\n                                                                       -- see https://www.juce.com/api/classKeyPress.html for\r\n                                                                       -- available key-codes\r\n    documentWindow:keyPressed(function(k)\r\n        local k, m = k:getKeyCode(), k:getModifiers() -- get current key-code and modifiers status\r\n        if (k==K\"Q\" or k==K\"q\") \r\n                and (m:isCommandDown() or not(app.os.osx)) then -- if Q is pressed or, on OS X, cmd+Q\r\n            app:exit(0)     -- close the application with an normal exit state (0 by default)\r\n\r\n        elseif (k==K\"w\" or k==K\"W\") and (m:isCommandDown() ) then -- if cmd/ctrl + W is pressed\r\n            documentWindow:closeWindow() -- close the window\r\n                                         -- on Linux and Windows, this has the effect of closing the application too,\r\n                                         -- but on OS X, only the active window is closed by default\r\n                                         -- however, if true is passed to closeWindow()\r\n                                         -- and this is the last remaining Document\r\n                                         -- the app will close the window and quit the application\r\n        elseif (k==kc.spaceKey) then\r\n            -- toggle rendering pause\r\n            isPaused = not(isPaused)\r\n        else\r\n            return false -- don't consume key\r\n                         -- returning false, nil or not returning anything\r\n                         -- has the same effect\r\n        end\r\n        return true     -- tell the OS we have consumed this key\r\n    end)\r\n\r\n    ---\r\n    -- add all components and display\r\n    ---\r\n\r\n    mc:setSize(wsize)\r\n    mc:addAndMakeVisible(button)                -- add the component to our main component\r\n    documentWindow:setContentOwned( mc, true )  -- add the main component to the document window\r\n\r\n    ---\r\n    documentWindow:closeButtonPressed(function() -- the user asked to close the current window...\r\n        documentWindow:closeWindow()             -- so let's close it our way\r\n                                                 -- if this action's not taken, it'll close the app by default\r\n    end)\r\n    documentWindow:setSize(wsize)   -- set dimensions for the window\r\n                                    -- on iOS and Android, it'll just set a fullscreen\r\n    documentWindow:setVisible(true) -- display the document\r\n    return documentWindow           -- return it for the application to actually display it\r\nend\r\n\r\nlocal manual      = false       -- set true if you want to add your own process running along with the main loop\r\nlocal osx_delayed = false       -- set true if you don't want your app to display a window immediatly on OS X\r\n                                -- but wait for user input before, like providing a file,...\r\nlocal poller      = function()  -- the callback you want to run in manual mode\r\n    print \"I'm in a loop!\"\r\nend\r\nreturn app:start( MainWindow, osx_delayed, manual, manual and poller ) -- returns the exit state\r\n```\r\n\r\n## A more complete example using only the low level API\r\n\r\n```lua\r\nlocal luce = require\"luce\"()\r\n\r\n---\r\n--- create a default JUCEApplication\r\n---\r\nlocal mainWindow = luce:JUCEApplication(\"My App\")\r\n\r\n---\r\n--- create a DocumentWindow with name \"Document Window\"\r\n---\r\nlocal dw = luce:DocumentWindow(\"Document Window\")\r\n-- rename it\r\ndw.name = \"Luce Example Application\"\r\n\r\n---\r\n--- create a MainComponent, to be hosted by the Document Window\r\n---\r\nlocal mc = luce:MainComponent(\"The Main Component\")\r\n\r\n---\r\n--- create a button named \"TheButton\" with text \"a button\"\r\n---\r\nlocal button = luce:TextButton(\"TheButton\")\r\nbutton:setButtonText( \"a button\" ) -- or button.buttonText = \"a button\", like button2 below\r\n\r\n--- add a callback for when button is clicked\r\nbutton:buttonClicked(function(...)\r\n    print(\"button clicked !!\")\r\nend)\r\n\r\n--- change component look and feel\r\nlocal button2 = luce:TextButton(\"TheButton2\")\r\nbutton2.buttonText = \"button with a different look and feel\"\r\n\r\n--- add a callback for when button is clicked\r\nbutton2:buttonClicked(function(...)\r\n    print(\"button 2 clicked !!\")\r\nend)\r\n\r\n--- set a different look and feel for button2\r\nbutton2:setLookAndFeel(3)\r\n\r\n---\r\n--- create a Label\r\n---\r\nlocal label = luce:Label(\"A Label\")\r\n\r\n--- Label's setText has an optional parameter to send a notification when its content's changed\r\n--- by default, it sends nothing:\r\nlabel.text = \"a bit of content\" -- default to dontSendNotification\r\n\r\n--- set a callback for label text changes\r\nlabel:labelTextChanged(function(...)\r\n    print(\"Label text has changed: \", label:getText()) -- or label.text\r\nend)\r\n--- but we could use one of the three notification methods accepted:\r\n--- sendNotification, sendNotificationSync or sendNotificationAsync\r\n--- by using the setText method:\r\nlocal notif = luce.NotificationType.sendNotification\r\nlabel:setText( \"another content\", notif )\r\n\r\n--- set label editable\r\nlabel:setEditable(false, true, true) -- edit on single click, edit on double click, \r\n                                     -- cancel changes when losing focus\r\n--- we can attach the label to the button too                                     \r\nlabel:attachToComponent( button, true ) -- component, true: onLeft/false: above (default)\r\nprint( \"is attached on left ?\", label:isAttachedOnLeft())\r\n\r\n\r\n--- set a colour for background and align text to the right\r\nlocal label2 = luce:Label(\"Another Label\")\r\nlabel2.text = \"(left aligned)\"\r\nlabel2:setColour( label2.ColourIds.backgroundColourId, luce.Colours.yellow )\r\nlabel2:setJustificationType( luce.JustificationType.right )\r\n\r\n--- centre text\r\nlocal label3 = luce:Label(\"(left aligned text)\")\r\nlabel3.text = \"(centered)\"\r\nlabel3:setColour( label3.ColourIds.backgroundColourId, luce.Colours.red )\r\nlabel3:setJustificationType( luce.JustificationType.centred )\r\n\r\n---\r\n--- create a TextEditor\r\n---\r\nlocal te = luce:TextEditor(\"Text Editor\")\r\n\r\n--- directly set bounds for this component\r\nte.bounds = { 200, 250, 200, 200 } -- x, y, w, h\r\n-- or\r\n-- te.setBounds{ 200, 250, 200, 200 }\r\n\r\n--- add our Document Window and components to our main JUCE application\r\nmainWindow:initialise(function(...)\r\n    mc:setSize{800,600}\r\n    mc:addAndMakeVisible( button ) -- add the button to the main component\r\n    button:setBounds{ 200, 20, 200, 200 } -- give the button some dimensions\r\n    mc:addAndMakeVisible( label ) -- add the label          \r\n    --label:setBounds{ 20, 250, 100, 100 } -- don't set bounds to the label\r\n                                           -- if you want it attached to button\r\n\r\n    mc:addAndMakeVisible(te) -- add the Text Editor\r\n\r\n    mc:addAndMakeVisible( button2 ) -- add the second button with the different lnf\r\n    button2:setBounds{ 410, 20, 200, 200 }\r\n\r\n    mc:addAndMakeVisible(label2)\r\n    label2:setBounds{ 410, 230, 150, 30 }\r\n\r\n    mc:addAndMakeVisible(label3)\r\n    label3:setBounds{ 410, 270, 150, 30 }\r\n\r\n    --mc:setBounds{ 0, 0, 800, 600 } -- set the component bounds\r\n                                     -- as this is the last component before\r\n                                     -- DocumentWindow, it'll set the window size\r\n                                     -- too, unless dw sets one\r\n    dw:setContentOwned( mc, true )\r\n\r\n    dw:centreWithSize{800, 600} -- centre window on screen with size 800x600\r\n    --dw:setCentrePosition{ 0, 0 } -- move it to the top left corner\r\n\r\n    --dw:setBounds{ 100, 100, 800,600 } -- sets the window bounds\r\n                                        -- as dw is a TopWindow and, as such, the very 1st component,\r\n                                        -- it'll be positionned\r\n                                        -- on screen directly, so that's another way of\r\n                                        -- doing centreWithSize/setCentrePosition\r\n    --dw:setSize{ 800,600 } -- just show the window, top left corner\r\n    dw:setVisible(true)\r\n\r\n    return dw -- return the Document Window so the JUCE Application can take it\r\nend)\r\n\r\n--- callback on DocumentWindow :closeButtonPressed\r\ndw:closeButtonPressed(function(...)\r\n    print(\"*** DocumentWindow close button pressed\")\r\nend)\r\n\r\n--- callback used when quit is asked\r\nlocal stop_now = false\r\nmainWindow:systemRequestedQuit(function(...)\r\n    print(\"** MainWindow system requested quit\")\r\n    stop_now = true\r\n    mainWindow:shutdown()\r\n    mainWindow:quit()\r\nend)\r\n\r\n--- main loop\r\n\r\n--- there are two implementations of the main loop\r\n--- one is the JUCE's native wrapped one\r\n--- and the other one gives control over the loop\r\n--- so actions can be taken during the process execution\r\n\r\n-- luce:start( mainWindow ) -- the simplest one, everything's under \r\n                            -- JUCE control\r\n\r\n--- and the non automatic one\r\n--- the function's executed in a loop within a thread,\r\n--- so there's no need to loop here\r\n--- it is set with the same rate than the JUCE's loop (1ms by default)\r\nluce:start_manual( mainWindow, function(...)\r\n    -- do some stuff, like zmq:poll(), for instance\r\n    return stop_now\r\nend )\r\n```\r\n\r\n## More examples\r\n\r\nFor more examples, see the [examples](https://github.com/peersuasive/luce/tree/master/examples) \r\nfolder of the repository.\r\n\r\n# Requirements and dependencies\r\n\r\nTo simply use Luce as a module,\r\n\r\n-   lua 5.1 / lua 5.2 / luajit 2.X\r\n\r\n## to compile the module and for C++ projects\r\n\r\n-   C++11\r\n-   GCC 4.6+ / CLANG 3.3+\r\n\r\n## to extend with new JUCE classes\r\n\r\n-   `JUCE` 3.0.4+\r\n\r\n# Downloads\r\n\r\nAs of v0.3.1, modules are available for both lua5.1/luajit2.X and\r\nlua5.2.\r\n\r\nTo use with lua scripts as a module, pick the module download.\r\n\r\nIf you want to contribute and help debugging, get the debug version of\r\nthe module also.\r\n\r\nAnd if you want to use\r\n[Luce/Embedded](https://github.com/peersuasive/luce_embeddable) or\r\ndevelop with C++, get the static library (or use the module as a shared\r\nlibrary, if you prefer to).\r\n\r\nFor iOS, only the static library is available as Apple policies wouldn't\r\nallow a shared version but if you'd like to deploy on jailbroken\r\ndevices, just ask, I'll provide it with the next release.\r\n\r\nFor Android, at the opposite, only the shared library/module is\r\navailable, as a static library wouldn't really make sense, but feel free\r\nto ask also.\r\n\r\n## v0.3.1 (alpha)\r\n\r\n### Linux64 5.1\r\n\r\n-   [Linux/64/2.13 (lua 5.1\r\n    module)](https://github.com/peersuasive/luce/releases/download/v0.3.1/luce.v0.3.1.linux64-5.1.zip)\r\n-   [Linux/64/2.13 (lua 5.1\r\n    module/debug)](https://github.com/peersuasive/luce/releases/download/v0.3.1/luce.v0.3.1.linux64-5.1_dbg.zip)\r\n-   [Linux/64/2.13\r\n    (static)](https://github.com/peersuasive/luce/releases/download/v0.3.1/luce.v0.3.1.Linux64-5.1_static.zip)\r\n\r\n### Linux64 5.2\r\n\r\n-   [Linux/64/2.13 (lua 5.2\r\n    module)](https://github.com/peersuasive/luce/releases/download/v0.3.1/luce.v0.3.1.linux64-5.2.zip)\r\n-   [Linux/64/2.13 (lua 5.2\r\n    module/debug)](https://github.com/peersuasive/luce/releases/download/v0.3.1/luce.v0.3.1.linux64-5.2_dbg.zip)\r\n-   [Linux/64/2.13\r\n    (static)](https://github.com/peersuasive/luce/releases/download/v0.3.1/luce.v0.3.1.Linux64-5.2_static.zip)\r\n\r\n### Win32 5.1\r\n\r\n-   [Windows/32 (lua 5.1\r\n    module)](https://github.com/peersuasive/luce/releases/download/v0.3.1/luce.v0.3.1.win32-5.1.zip)\r\n-   [Windows/32 (lua 5.1\r\n    module/debug)](https://github.com/peersuasive/luce/releases/download/v0.3.1/luce.v0.3.1.win32-5.1_dbg.zip)\r\n-   [Windows/32\r\n    (static)](https://github.com/peersuasive/luce/releases/download/v0.3.1/luce.v0.3.1.win32-5.1_static.zip)\r\n\r\n### Win32 5.2\r\n\r\n-   [Windows/32 (lua 5.2\r\n    module)](https://github.com/peersuasive/luce/releases/download/v0.3.1/luce.v0.3.1.win32-5.2.zip)\r\n-   [Windows/32 (lua 5.2\r\n    module/debug)](https://github.com/peersuasive/luce/releases/download/v0.3.1/luce.v0.3.1.win32-5.2_dbg.zip)\r\n-   [Windows/32\r\n    (static)](https://github.com/peersuasive/luce/releases/download/v0.3.1/luce.v0.3.1.win32-5.2_static.zip)\r\n\r\n### OS X 5.1\r\n\r\n-   [Mac OS X/64/10.8 (lua 5.1\r\n    module)](https://github.com/peersuasive/luce/releases/download/v0.3.1/luce.v0.3.1.osx64-5.1.zip)\r\n-   [Mac OS X/64/10.8 (lua 5.1\r\n    module/debug)](https://github.com/peersuasive/luce/releases/download/v0.3.1/luce.v0.3.1.osx64-5.1_dbg.zip)\r\n-   [Mac OS X/64/10.8\r\n    (static)](https://github.com/peersuasive/luce/releases/download/v0.3.1/luce.v0.3.1.osx64-5.1_static.zip)\r\n\r\n### iOS 6.1 5.1\r\n\r\n-   [iOS/5.1 (lua 5.1\r\n    static)](https://github.com/peersuasive/luce/releases/download/v0.3.1/luce.v0.3.1.ios61-5.1.zip)\r\n\r\n### Android 4.4 5.1\r\n\r\n-   [Android/4.X (lua 5.1\r\n    shared)](https://github.com/peersuasive/luce/releases/download/v0.3.1/luce.v0.3.1.android44-5.1.zip)\r\n\r\n# What's implemented so far ?\r\n\r\nBasically, most of the core components are implemented, as well as\r\nOpenGL.\r\n\r\nMost of the Graphics painting operations are also implemented, as well\r\nas the most usefull math/geometry classes.\r\n\r\nSome components you might find usefull may be missing, so don't hesitate\r\nto ask for adding (or fork the repo and follow the guide [Adding new\r\nclasses to Luce](#Adding new classes to Luce) then send a *pull request*).\r\n\r\n# Luce design\r\n\r\nAll Luce classes start with a `L`.\r\n\r\nLuce design is close to JUCE's, but often simplfied when it doesn't make\r\nsense in lua to keep some if its behaviour or features.\r\n\r\nFor the general GUI design, see JUCE.\r\n\r\nAll widgets are derived from Juce's Component class and Luce's\r\nLComponent class. All non-widgets classes are derived from LBase.\r\nLComponent itself is derived from LBase. LBase offers the required link\r\nto Lua while LComponent offers the required links to Juce.\r\n\r\nMost of the callbacks existing in Juce also exist in Luce; in the same\r\nmanner they need to be overriden in Juce to take effect, they also need\r\nto be overriden in Luce, that is, as for Luce, that a lua function needs\r\nto be provided for the callback to be effective. If no callback is\r\nprovided, the default Juce action is called, if any.\r\n\r\nAll L\\* classes map their Juce equivalent or are specific to Luce (like\r\nLBase).\r\n\r\nAll L\\* classes are overridable within lua code, like any pure lua\r\nmodules, and most of them are partly implemented in Lua. This is\r\nparticularly useful for callback declarations or to add actions to\r\nnative methods or simply to specialise a component with new\r\nfunctionnalities. This is the mechanism we use to implement C++ classes\r\ndirectly in Lua.\r\n\r\nThere's a limitation, though, unless it's a callback, as it's not\r\npossible to reimplement a native method in lua -- hence the use of a lua\r\nclass wrapping the native one.\r\n\r\n# Differences with `JUCE`\r\n\r\nFor simplicity and reference, `Luce` usually uses the same method names\r\nthan `JUCE`. However, where `JUCE` uses getters/setters, Luce offers a\r\ndirect value attribution, whenever possible and obvious, that is. For\r\ninstance, `setName(\"...\")` and `getName()` would be replaced with\r\n`name [= \"...\"]`, though set/get methods are still accessible.\r\n\r\nSo JUCE documentation is applicable for most of the Luce's low level\r\ncomponents.\r\n\r\n`Luce` doesn't provide any listener class directly (and probably won't)\r\nbut instead wraps the listeners, where relevant, on the C++ side; as\r\nsuch, there's no point in having `addListener` and `removeListener`\r\nfunctions taking a listener class as argument; but one would be able to\r\nenable or disable such listeners so these methods still exist in `Luce`\r\nthough they just activate/deactivate the wrapped Listener.\r\n\r\nSome future use cases may reveal the need for such an availability but\r\nat the moment, we haven't found any.\r\n\r\nAnother difference is with Rectangle and Point objects, for which we\r\ndidn't find any use to provide natively. These classes are provided as\r\npure lua indexed tables and recreated wherever needed. So where a `JUCE`\r\nmethod needs a `Rectangle` or `Point` object, a table containing the\r\nvalues must be provided instead. Order is always x, y [, w, h ]. In\r\ngeneral speaking, it respects the order declared in the class\r\nconstructor. Later on, there'll probably be a lua implementation of\r\nthese classes, to offer some of their most useful methods, like\r\n`:reduce()`.\r\n\r\n# Adding new classes to Luce\r\n\r\nThere are two kinds of sses in `Luce`: *full* classes and *wrapper*\r\nclasses.\r\n\r\nFull classes are just `JUCE` classes extended to be integrated with\r\n`Luce`, while wrapper classes are there to create some kind of\r\ninheritence between `Luce` components.\r\n\r\nFor the 1st one, see `LLabel`, `LTextEditor` or `LTextButton`, while the\r\nonly example for the 2nd kind is `LComponent`.\r\n\r\n`LLabel`, `LTextEditor` and `LTextButton` extend their respective `JUCE`\r\ncomponent while inheriting `LComponent`, which in turn wraps all\r\n`JUCE`'s `Component` base class methods.\r\n\r\nThis allows simulating inheritence in `Luce` components, as it wouldn't\r\nbe possible in a simple way otherwise. Like previously said, we're not\r\naiming at a 1 to 1 binding to `JUCE`, so more complex mechanisms would\r\nbe oversized here (unless someone knows a simple way to achieve this, of\r\ncourse !).\r\n\r\nThere is a helper script, `microparser`, which greatly simplify the job\r\nof creating new classes for `Luce`. It won't generate a new \"ready to\r\nuse\" class but gives a great help by generating the class template and\r\nheaders with all available methods and callbacks and pre-implementing\r\nthem. The most obvious ones are fully generated.\r\n\r\nTo add pseudo-inheritence, use the script `create_inh.sh`:\r\n\r\n```bash\r\n./create_inh.sh <Luce_CLASS_BASE_NAME>\r\n```\r\n\r\nwhich generates the `LCLASS_inh.h` header to be included in the class.\r\n\r\nOnce the class is created, include it in `luce.cpp`, `luce.h` and\r\nreference it in `Main.cpp`:\r\n\r\n```c++\r\nint l_NewClass(lua_State *L) {\r\n    Luna<LNewClass>::Register(L);\r\n    return 1;\r\n}\r\n\r\nstatic const luaL_reg luce_lib [] = {\r\n    { \"NewClass\", l_NewClass },\r\n    [...]\r\n    {NULL, NULL}\r\n};\r\n```\r\n\r\n# Roadmap\r\n\r\n`Luce` is still very young but growing fast -- at least as fast as our\r\nneeds for it. Most of the basic widgets are aleady there and it's\r\nalready possible to build full applications with it. Performances are\r\nthere too, even if there isn't any optimisation done yet.\r\n\r\nNext big steps are:\r\n\r\n-   implementating a high level API (porcelaine) to simplify the process\r\n    of creating new applications and reduce the number of required calls\r\n    and methods to the native (JUCE) API\r\n-   more low level binding, like box2d, to be able to create our own\r\n    fancy widgets\r\n-   an equivalent to JUCE's message broadcasting, between C++/Lua but\r\n    also between any components (gadokai? pure ømq?)\r\n-   a var/Value equivalent usable within lua, even out of any JUCE\r\n    context (gadokai? ømq?)\r\n-   some minor tasks like overriding LookAndFeel lua side\r\n-   optimisation, if required (there's a looooot of room for\r\n    optimisation, no worry at all on this side)\r\n\r\nAPI documentation will come later as Juce's one is still fully relevant.\r\n\r\nYou may also want to have a look at\r\n[luz](https://github.com/peersuasive/luz), a simple demonstrator on\r\nremotely and dynamically creating a `Luce` application, a small *avant\r\ngoût* of the forthcoming Peersuasive's smart-data oriented architecture\r\n`gadokai` (yet to be announced).\r\n\r\n# Related Projects\r\n\r\n[Luce Embeddable](https://github.com/peersuasive/luce_embeddable), to\r\ncreate standalone or bundled applications.\r\n\r\n[Luce Squishable](https://github.com/peersuasive/luce_squishable), to\r\nconcatenate Luce's lua classes to one, portable file.\r\n\r\n# License.\r\n\r\nFor open source projects, `Luce` is licensed under the terms of the\r\n[GPLv3](http://www.gnu.org/licenses/gpl-3.0.html) with some parts being\r\n[AGPLv3](http://www.gnu.org/licenses/agpl-3.0.html).\r\n\r\nFor commercial projects and professional support, please contact us at contact@peersuasive.com.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}